#include "stdafx.h"
#include "Packets.h"
#include "..\SharedFiles\lzf.h"

using namespace std;

CUser::CUser(uint16 socketID, SocketMgr* mgr) : OHSocket(socketID, mgr, -1, 16384, 3172), Unit(true)
{
	m_curServerInstance = NULL;
}

void CUser::OnConnect()
{
	OHSocket::OnConnect();
	m_remaining = 0;
	m_usingCrypto = false;
	m_readTries = 0;
	m_sequence = 0;
	Initialize();
}

void CUser::Initialize()
{
	m_maxHp = 0;
	m_maxChi = 0;
	m_minDamage = 0;
	m_maxDamage = 0;
	m_minSkillDamage = 0;
	m_maxSkillDamage = 0;
	m_def = 0;
	m_skillDef = 0;
	m_pvpDef = 0;
	m_pvpSkillDef = 0;
	m_accuracy = 0;
	m_dodge = 0;
	m_poisonAtk = 0;
	m_poisonDef = 0;
	m_confusionAtk = 0;
	m_confusionDef = 0;
	m_paralysisAtk = 0;
	m_paralysisDef = 0;
	m_pvpDamage = 0;
	m_pvpSkillDamage = 0;
	m_attackSpeed = 1000;
	m_movementSpeed = 6.0f;//TODO: Figure out this standard value

	ResetItemSlotValues();

	m_state = GAME_STATE_CONNECTED;
	m_inCombatState = false;
	m_isMeditating = false;
	m_accountId.clear();
	m_selectedCharacter = false;

	m_userData = new _USER_DATA();

	m_userData->m_morphId = 0;
	m_chatHandler = new ChatHandler();

	m_target = this;

	m_meditationTimer.Reset(MEDITATION_TICK);
	m_abnormalType = ABNORMAL_BLINKING;

	m_currentGossip = NULL;
}

void CUser::ResetItemSlotValues()
{
	m_itemMinDmg = 0;
	m_itemMaxDmg = 0;
	m_itemDelay = 0;
	m_itemAttackRange = 0;
	m_itemAttackAoE = 0;
	m_itemStatBonus[STAT_STR] = 0;
	m_itemStatBonus[STAT_DEX] = 0;
	m_itemStatBonus[STAT_INT] = 0;
	m_itemStatBonus[STAT_WIND] = 0;
	m_itemStatBonus[STAT_WATER] = 0;
	m_itemStatBonus[STAT_FIRE] = 0;
	m_itemPoisonDmg = 0;
	m_itemParalysisDmg = 0;
	m_itemConfusionDmg = 0;
	m_itemPoisonDef = 0;
	m_itemParalysisDef = 0;
	m_itemConfusionDef = 0;
	m_itemMaxHp = 0;
	m_itemMaxChi = 0;
	m_itemHpRecoveryPercent = 0;
	m_itemChiRecoveryPercent = 0;
	m_itemMovementSpeed = 0;
	m_itemMinBonusDmg = 0;
	m_itemMaxBonusDmg = 0;
	m_itemBonusDmgPercent = 0;
	m_itemMinBonusSDmg = 0;
	m_itemMaxBonusSDmg = 0;
	m_itemBonusSDmgPercent = 0;
	m_itemDefense = 0;
	m_itemDefensePercent = 0;
	m_itemSDefense = 0;
	m_itemSDefensePercent = 0;
	m_itemAccuracy = 0;
	m_itemDodge = 0;
	m_itemCritChance = 0;
	m_itemBonusExp = 0;
	m_itemDropBonus = 0;
	m_itemBonusMineral = 0;
}

void CUser::OnDisconnect()
{
	if (IsInGame())
	{
		UserLeaveEnterRegion(2);
		g_main->m_dbAgent.SaveUser(m_userData);
		g_main->m_dbAgent.SaveUserInventory(m_userData);
		g_main->m_dbAgent.SaveUserWarehouse(m_userData, m_accountId);
		RemoveRegion(GetRegionX(), GetRegionZ());
		GetMapInstance()->RemoveUser(this);
		g_main->GetServerInstanceMgr()->RemoveUserFromServerInstance(this, m_curServerInstance->m_serverInfo->m_tabId, m_curServerInstance->m_serverInfo->m_serverId);
	}

	//TODO: Replace the save functions with something in g_main?
	OHSocket::OnDisconnect();
	g_main->RemoveSessions(this);

	delete m_userData;
	delete m_chatHandler;
}

bool CUser::HandlePacket(Packet& pkt)
{
	uint8 opCode = pkt.GetOpcode();
	if (opCode == PKT_GAMESERVER_CHARSEL_SCREEN)
	{
		uint8 subOpcode;
		pkt >> subOpcode;
		if (!isCryptoEnabled() || m_accountId.empty())
		{
			if (subOpcode == CSS_VERSION_CHECK)//TODO: Still not happy with this auth stuff, it's not safe..
				HandleVersionCheck(pkt);
			return true;
		}
		else if (!m_selectedCharacter)
		{
			switch (subOpcode)
			{
			case CSS_REQUEST_ALL_CHAR:
				HandleAllCharListRequest(pkt);
				break;
			case CSS_CREATE_CHAR:
				HandleCharCreation(pkt);
				break;
			case CSS_DELETE_CHAR:
				HandleDeleteCharacter(pkt);
				break;
			case CSS_SELECT_CHAR:
				HandleSelectCharacter(pkt);
				break;
			default:
				break;
			}
			return true;
		}
		else
			return false;
	}

	//For ingame stuff.
	switch (pkt.GetOpcode())
	{
	case PKT_GAMESERVER_LOADINGSCREENUNK1:
		break;
	case PKT_GAMESERVER_LOADINGSCREENUNK2:
		break;
	case PKT_GAMESERVER_LOADINGSCREENUNK3:
		HandleLoadingscreenUnk3(pkt);
		break;
	case PKT_GAMESERVER_MESSAGE:
		m_chatHandler->HandleChat(pkt, this);
		break;
	case PKT_GAMESERVER_CHARACTER_MOVE:
		HandleCharacterMovement(pkt);
		break;
	case PKT_GAMESERVER_ZONE_CHANGE:
		HandleZoneChange(pkt);
		break;
	case PKT_GAMESERVER_REQUEST_ATTACK:
		HandleAttack(pkt);
		break;
	case PKT_GAMESERVER_REQUEST_ATTACK_AOE:
		HandleAoeAttack(pkt);
		break;
	case PKT_GAMESERVER_REQUEST_CAST_SKILL:
		HandleSkillPackets(pkt);
		break;
	case PKT_GAMESERVER_CHANGE_COMBAT_STATE:
		HandleChangeCombatState(pkt);
		break;
	case PKT_GAMESERVER_REQUEST_CAST_TIMED_SKILL:
		HandleTimedCastSkillRequest(pkt);
		break;
	case PKT_GAMESERVER_WORLD_MAP_TELEPORTER:
		HandleWorldMapTeleporter(pkt);
		break;
	case PKT_GAMESERVER_MODIFY_ITEM:
		HandleItemModification(pkt);
		break;
	case PKT_GAMESERVER_ADD_ITEM_CONTINUOS:
		HandleNpcGossip(pkt);
		break;
	case PKT_GAMESERVER_ITEM_STACK_CHANGE:
		HandleNpcExchange(pkt);
		break;
	case PKT_GAMESERVER_MOVE_ADD_ITEM:
		HandleMoveItem(pkt);
		break;
	case PKT_GAMESERVER_BANK_MOVE_GOLD:
		HandleBankGold(pkt);
		break;
	case PKT_GAMESERVER_SKILLBOOK_SKILL:
		HandleSkillBookPackets(pkt);
		break;
	case PKT_GAMESERVER_MEDITATE:
		HandleMeditation(pkt);
		break;
	case PKT_GAMESERVER_ADD_STATPT:
		HandleAddStatPt(pkt);
		break;
	case PKT_GAMESERVER_TARGET:
		HandleTargetChange(pkt);
		break;
	case PKT_GAMESERVER_ATTACK_SKILL_FINISH:
		FinishAttackRequest();
		break;
	default:
		break;
	}

	return true;
}

void CUser::HandleVersionCheck(Packet& pkt)
{
	if (!m_accountId.empty())
		return;

	Packet result(PKT_GAMESERVER_CHARSEL_SCREEN, uint8(CSS_VERSION_CHECK));

	string accID;
	int16 unk; //0130 allways
	uint32 unk2;// 4 bytes, first is version, other 3 idk.

	pkt >> accID >> unk >> unk2;

	m_accountId = accID;
	//Updates account session.
	if (!g_main->m_dbAgent.GetAccountSession(this))
	{
		Disconnect();
		return;
	}

	if (g_main->m_accountNameMap.find(accID) != g_main->m_accountNameMap.end())
	{
		Disconnect();
		return;
	}
	
	g_main->AddAccountName(this);//TODO: This still isn't that safe, we now check the IP address of the player, and that he did select a server on that account, but that's not realy safe.

	result << unk2 << m_crypto.GenerateKey();//uint8(0xCF) << uint8(0x47) << uint8(0xAC) << uint8(0xA2) << uint8(0x6E) << uint8(0x47) << uint8(0x49) << uint8(0x17);// uint64(0xC4F531BF15A61653); NEW KEY 0xCF47ACA26E474917
	Send(&result);

	EnableCrypto();
}

void CUser::HandleAllCharListRequest(Packet& pkt)
{
	Packet result(PKT_GAMESERVER_CHARSEL_SCREEN, uint8(CSS_REQUEST_ALL_CHAR));

	std::vector<std::string> charIds;
	uint8 count = 0;

	result << uint8(0x0a);//Unk
	if (!g_main->m_dbAgent.GetAllCharByAccount(m_accountId, count, charIds))
	{
		result << uint32(0x00000000);
		Send(&result);
		return;
	}
	m_userData->m_charCount = count;

	result << uint8(0x00);//Unk
	result << uint8(0x01);// Old faction choice, 00 enabled, 01 disabled.
	result << uint8(m_userData->m_faction);//Faction. 0 none 1 Zhuang 2 Shao
	result << uint8(count);//Char num
	result << uint8(0x00);//Last used char, 0 index.
	//result << uint16(0xb55d);//Unk In LoadCharInfo now.
	//result << uint16(0x0000);//Unk
	uint8 counter = 1;
	foreach(itr, charIds)
	{
		g_main->m_dbAgent.LoadCharInfo((std::string)*itr, counter, result); //Works j ust fine, but something is wrong with the packet structure now.
		counter++;
	}
	Send(&result);
}

void CUser::HandleCharCreation(Packet& pkt)
{
	uint8 errorCode = 0x00;
	uint8 unk;
	std::string charId;
	uint8 charType, faction;
	uint8 height; //00 means normal, 02 means 4(highest) fe 0(lowest) FE-02 range
	uint32 hairType;
	uint32 faceType;
	bool updateFaction = false;

	Packet result(PKT_GAMESERVER_CHARSEL_SCREEN, uint8(CSS_CREATE_CHAR));

	pkt >> unk >> charId >> charType >> faction;

	if (m_userData->m_faction == 0)
	{
		if (faction < 1 || faction > 2)
		{
			errorCode = 0xE9;//Incorrect account.
			goto return_fail;
		}
		updateFaction = true;
		m_userData->m_faction = faction;
	}
	pkt >> height >> hairType >> faceType;

	if (m_userData->m_charCount > MAX_USER_CHARACTERS - 1)
	{
		errorCode = 0xE1;
		goto return_fail;
	}

	if (charId.empty() || charId.length() > MAX_ID_SIZE || charId.length() < 3)
	{
		errorCode = 0xEB;//Bad name
		goto return_fail;
	}
	
	if (sObjMgr->GetCharacterInfo(charType) == NULL)
	{
		errorCode = 0xE1;
		goto return_fail;
	}

	//TODO: Also hair and facetype valid.

	if (height < 0xFE && height > 2)
	{
		errorCode = 0xE9;
		goto return_fail;
	}
	int8 ret = g_main->m_dbAgent.CreateCharacter(m_accountId, m_userData->m_faction, charId, charType, height, hairType, faceType, updateFaction);

	if (ret < 1)
	{
		if (updateFaction)
			m_userData->m_faction = 0;
		errorCode = 0xEC;
		goto return_fail;
	}

	if (updateFaction)//Only ever run once per account.
		g_main->m_dbAgent.UpdateAccountFaction(m_accountId, m_userData->m_faction);

	//Check hair and face stuff
	result << uint8(0x0A); //Success?
	result << uint16(0x0000); //Unk
	result << uint8(0x57); //unk
	result << uint8(0x86); //unk
	result << uint16(0x0000); //unk
	result << charId;

	Send(&result);
	return;

return_fail:
	result << uint8(errorCode);
	result << uint8(0x03);
	Send(&result);
	return;
}

void CUser::HandleDeleteCharacter(Packet& pkt)
{
	Packet result(PKT_GAMESERVER_CHARSEL_SCREEN, uint8(CSS_DELETE_CHAR));

	uint8 unk;
	std::string charId;
	pkt >> unk >> charId;

	int8 ret = g_main->m_dbAgent.DeleteCharacter(m_accountId, charId);

	if (ret < 0)
	{
		result << uint8(0xE2);
		result << uint8(0x03);
		Send(&result);
		return;
	}

	result << uint8(0x0A);//Success code i believe
	result << uint8(0x00);//Unk
	result << uint8(0x03);//Also some sucess thing
	result << charId;
	Send(&result);
}

void CUser::HandleSelectCharacter(Packet& pkt)
{
	uint16 uniqueId;//5D B5 Char identity?
	uint16 unk2;//00 00 maybe uniqueId is 32bit?
	uint8 unk3, unk4;//E8 03
	uint32 unk5;//00 00 00 00
	uint8 unk6, unk7;//01(zone?) 7B

	pkt >> uniqueId >> unk2 >> unk3 >> unk4 >> unk5 >> unk6 >> unk7;
	
	Packet result(PKT_GAMESERVER_CHARSEL_SCREEN, uint8(CSS_SELECT_CHAR));

	//if (isBanned())
	//{
	//	Disconnect();
	//	return;
	//}
	//CHECKS!
	if (m_selectedCharacter)
	{
		result << uint8(0xEC);
		result << uint8(0x03);
		Send(&result);
		return;
	}

	int8 ret = g_main->m_dbAgent.GetCharNameByUniqueId(m_accountId, uniqueId, *m_userData->m_charId);
	CUser* pUser = g_main->GetUserPtr(m_accountId.c_str(), NAME_TYPE_ACCOUNT);
	if (ret < 0 || !pUser || (pUser->GetSocketID() != GetSocketID()))
	{
		result << uint8(0xEC);
		result << uint8(0x03);
		Send(&result);
		return;
	}
	g_main->AddCharacterName(this);
	
	if (!g_main->m_dbAgent.LoadUserData(m_accountId, std::string(m_userData->m_charId), m_userData) ||
		!g_main->m_dbAgent.LoadWarehouseData(m_accountId, m_userData))
		return;
	//g_main->m_dbAgent.LoadPremiumServiceUser(m_accountId, m_userData);TODO: Implement premium stuff, realy not important

	g_main->GetServerInstanceMgr()->AddUserToServerInstance(this, m_serverTab, m_serverId);

	//SERVER_INSTANCE_CHANGE
	//SetCurrentMap(g_main->GetZoneById(m_userData->m_zone));
	//if (GetMap() == NULL)
	//	return;

	SetCurrentMapInstance(m_curServerInstance->GetMapInstanceByZoneId(m_userData->m_zone));
	if (GetMapInstance() == NULL)
		return;

	m_selectedCharacter = true;

	UpdateItemSlotValues();
	UpdateUserStats();

	if (GetLevel() > MAX_PLAYER_LEVEL)
	{
		Disconnect(); 
		return;
	}

	result << uint8(0x0A);//SUCCESS
	result << uint8(0x00);//Unk
	Send(&result);
}

void CUser::HandleLoadingscreenUnk1(Packet& pkt)
{
	
}

void CUser::HandleLoadingscreenUnk2(Packet& pkt)
{
	
}

void CUser::HandleLoadingscreenUnk3(Packet& pkt)
{
	Packet result(0x24);//Packet result(0x72);
	
	//ByteBuffer temp, temp2;
	uint8* arr;
	//uint8 temp;
	//uint16 compLen, orgLen;
	//uint32 crc;
	int len = 0;
	//this is compressed char select.
	//arr = HEXSTRTOBYTEARR2("75017B051D790501020A0001010500D90D000006536974616D61451F970000001003022005E0000005E6120B01A601C00E001B20080DE122C701B50FCB01A2010001000620100100162004047211D100E8802BA03F001D2015402B07DCB7EF00A4010003802B40000733ACCA00238A09012015000420012000007320030B0518C7003426F207A214000580150025201504AE29D10053802B0006801500792015402B00B88015000780150009201504F5C2D000B68015000880150007A01500E7809940242000001C20034099075F9C00002A64640A209B200040C50553C9CB0001DA211207054D7567656E340240F9020103FE201EE01D00402FE00900A111E006000003E0060F800000048006E006000005E0060F8000617DE0080040F4E009000008E009122000A111E00600000AE0050F1002136B00000A5261726542616E6B65723BE12816E0CC0002038E7D21160A4D65676144696E67757338A116E021ECE2CC2D0A04CF850000127061706572E00404E1FC1E010000", len);
	//Below is char info/inv
	//arr = HEXSTRTOBYTEARR2("4b073d181f3b1808ae02d90d000006536974616d61451f031008a67c430c68784286ef294108970000001b2b0000c82007009620010014200103ab03ab03200e600000c82001400000e7400405001c69027a362009032af5e67c40070d201c00002d2f000053310000dc13800360000503011e010102600a400005010004d18ed7600f0314a493d64012e021001d02323031362d30322d30362030323a35323a3436002e00e0b7ef0000a501204702f1f1f12005e00000030310495ee0000c800000e6a02b0001402b20008015200002020b492005e0040000e4a02b0002e0082b014865e00428200000dc402b05a401000300f060002012800001014a8007e0020003238a0901402b020400dd2000e002180303561110e0020e40000d3426f20700a214000500101816174011a00002024716a009e000000053a057020600db2000e000160400000266442005e0040000b8a02b0007e0072b010148e00427400000b6a02b0008e0072b0303154c424020e0020000e24107218b0009e10733040409452561e002282000015f9c2004032a64640a200602a000d1e002fa044269726469e1046308619df20000a13a000b202b0400003fc2a1200d02cd030c200bc00d01e70322db2000801b0212030e200b0200003e602902df030f200bc00d01e403806a801b02b003112019020000de20030400a1cb021240070100df400502a16a0222ca200000dc20030400a18202144007000061b203a1190315600d00fa400502a15900818e00fc600d015c0081aa00fb600d02a00018400701002e608b02850119600d0845e1f50500a1dc011a600d00b9a163001be107630102362359e0050000fe439302a1ef00801800ff600d0229021d80240004200603a130021e20060a0000c7fa070100a80f001f200be0170000ca602b020c0020e01728200000c9602b021d0021200be0170000c8602b020f0022e017282000002a611302070023200b0200002b600d020b0024200b0a000096120b0100a1010025200b030000b907400d0224003b200b0400008319f7214b029a013c200b0b000032882f0900a2ce073d0081a1e0130000eb401c05a201003e00eb600ae01300011d1040730278003f60240109ef250903a49d0240600de015000008402b08aa010041006a8300c144a9e0110001b40e40650112168359020800e620f70408a6010033e007360303202f2ee0064603b50fcb0140cd023401f26000e0001e02022038e0000ba00000e8a0570035e00757e0070f200000e7a02b0036e0071be0070f200000e842c920af0138012484e404850011e4088500eaa02b0039e0072b0303203a45204be0030000eba02b003ae0082b01062ce507ba00e9a02b003be0072b01024826a3e00500030300fc26213503a114003d60cd00fda00d003e600d00fea00d003f600d273ce000df0055a011e01300c0870056e01a2bc10b0057e0222b0058e007df0001e107090000e100370059e01a5702da4a5d23470201005ba02b094156f60500000accabf5204801003d200d25ab00422006030503024320064015e00400004c247e01035520040105512004010a524004004d4004e00425a000004ee000180053e00009e00b00004fe0001d0054e000090050e00009600001487120a660090049e00009004ae000096000004be0050e6000004c20138619004d20098040e00b00004e201d00576018004f2009803160000ac4090000146b4e0000077220040105c7200e010a6f4009601de00600006c201801037320040108c82027a162e00a00006d202201077420040105c9402700714009006e200445e8020000ca401301fc0820ef00fd400400fe2004806d000220188009e006000003e00f18e01f0000062040811c0060400900612004010962200480c200662009e00c770067e00f18e01f00006a204080f4e0e70004195af60506e01af4034531f70089040000cb1b0931332030393a34343a3225f2e009140039e01a55e015000003e00300c00d020202024003600440082003010302201c204a00024bed201f010207400de007004b32e00b00825be003002042a285801ce00b4de0090000032037010905203b400000012004200f2b1101020180c5201fa000400fc00ac007201e2002401a2027200380184005e0099ee01100210be002004083200024bfe0030002020301e027568000204ae01600c02720bf20290100008ad2e03900204c20cb010101e006c9200040c98000813100018000000340068017e0d200e001e16009212541262177800fe049008163e0ff00e0ff00e0ff00e0ff00e0100002170067201b64abe01c0000842025e0212d0006202a2002e01e000047202ae6094ee00f000058202d2002e01e00000c2582e0212d000f602d8af4e019000010602de01f000033602d50d5521f001ae016940034602d00d920252b0d000092e3e011000035602d0027e01120e004000036602d001b2013ea1b6c0037602d4113208ce018000038602d40002008e018000039202480552ccfe01800003be0002de81bcc003c602d5367ab2ae01400003d602d4000e21b89003ee0242d0020291980e5e01b00002ae0242d0033e0242d003ae0232d010000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//result >> compLen >> orgLen;
	//char* decBuf = new char[orgLen];
	//int64 res = lzf_decompress(result.contents() + result.rpos(), compLen, decBuf, orgLen);
	//pkt.Initialize(*decBuf);
	//if (orgLen > 1)
	//	pkt.append(decBuf + 1, orgLen - 1);
	////pkt >> crc;
	//crc32(pkt.contents() + 7, pkt.size() - 3);
	//std::ofstream out("decpacketo.txt", ofstream::out | ofstream::binary);
	//out.write(decBuf, orgLen);
	//Send(&pkt);

	//item start
	//arr = HEXSTRTOBYTEARR2("E0B7EF0000A501000000F1F1F10000000000000000000000000310495E000000000000000000000000000000E6B7EF0000A501000100F1F1F1F1F1F1000000000000000000020B4900000000000000000000000000000000E4B7EF0000A501000200F1F1F1F1F1F100000000000000000002486500000000000000000000000000000000DCB7EF0000A401000300F0F0F0F0F0F0000000000000000000014A0000000000000000000000000000000000238A090100A401000400DDDDDDDD0000000000000000000000035611100000000000000000000000000000003426F20700A21400050010181617000000000000000000000002471600000000000000000000000000000000538A090100A401000600DBDBDBDB000000000000000000000002664400000000000000000000000000000000B88A090100A401000700DBDBDBDB000000000000000000000001480000000000000000000000000000000000B68A090100A401000800DBDBDBDB000000000000000000000003154C42000000000000000000000000000000E2B7EF0000A501000900F1F1F1F1F1F1000000000000000000040945256100000000000000000000000000005F9C0000002A64640A000000A000D11000000000000000000000426972646965000000000000000000000000619DF20000A13A000B00000000003FC2A10000A1CD030C00000000003FC2A10000A1E7030D00000000003FC2A10000A112030E00000000003EC2A10000A1DF030F00000000003EC2A10000A1E4031000000000003EC2A10000A1B003110000000000DE00000000A1CB02120000000000DF00000000A16A02130000000000DC00000000A18202140000000000DD00000000A11903150000000000FA00000000A15900160000000000FC00000000A15C00170000000000FB00000000A1A0001800000000002EC2A10000A1850119000000000045E1F50500A1DC011A0000000000B98A090100A401001B00DBDBDBDB000000000000000000000002361C00000000000000000000000000000000FE03000000A1EF001C0000000000FF03000000A129021D00000000000004000000A130021E0000000000C7FA070100A80F001F0000000000000000000000000000000000000000000000000000000000000000000000CAFA070100A80C00200000000000000000000000000000000000000000000000000000000000000000000000C9FA070100A81D00210000000000000000000000000000000000000000000000000000000000000000000000C8FA070100A80F002200000000000000000000000000000000000000000000000000000000000000000000002AE1F50500A107002300000000002BE1F50500A10B0024000000000096120B0100A10100250000000000B9070B0100A124003B00000000008319F70500A19A013C000000000032882F0900A2CE073D0015000000000000000000000000000000000000000000000000000000000000000000EB00000000A201003E00EBEB00000000000000000000000000000000000000000000000000000000000000001D100B0100A178003F000000000009EFE70000A49D0240000000000000000000000000000000000000000000000000000000000000000000000008EFE70000AA010041006A8300C1010000000000000000000000000000000000000000000000000000000000B40E0B0100A112164200000000000800E6120B0108A60100330100000000000000000000000000000003202F2E000000000000000000000000000000B50FCB0100A201003401F2F2F2F2F2F200000000000000000002203800000000000000000000000000000000E8120B0108A60100350100000000000000000000000000000001000000000000000000000000000000000000E7120B0108A60100360100000000000000000000000000000001000000000000000000000000000000000000E88A090100A601003801DBDBDBDB000000000000000000000002114400000000000000000000000000000000EA8A090100A601003901DBDBDBDB000000000000000000000003203A45000000000000000000000000000000EB8A090100A601003A01DBDBDBDB000000000000000000000003062C49000000000000000000000000000000E98A090100A601003B01DBDBDBDB000000000000000000000002482F000000000000000000000000000000000300FC26CB0100A114003D0100000000FD26CB0100A114003E0100000000FE26CB0100A114003F010000000000000600E88A090100A60100550100000000000000000000000000000000000000000000000000000000000000000000E98A090100A60100560100000000000000000000000000000000000000000000000000000000000000000000EA8A090100A60100570100000000000000000000000000000000000000000000000000000000000000000000EA8A090100A601005801DBDBDBDB000000000000000000000001490000000000000000000000000000000000EB8A090100A60100590100000000000000000000000000000000000000000000000000000000000000000000DA4A5D0500A101005B010000000000004156F60500000ACCABF5000000003D56F6050A00004256F6050503024356F60500000000000000000000000000000000004C040000035504000005510400000A520400000A4D0400000A00000000000000000000000000000000000000004E0400000A0000000000530400000A000000000000000000000000000000000000000000000000004F0400000A0000000000540400000A0000000000500400000A00000000000000000000487100000A0000000000497100000A00000000004A7100000A000000000000000000004B7100000A0000000000000000000000000000004C7100000F00000000004D7100000A000000000000000000000000000000000000000000000000004E7100005700000000004F7100000F00000000000000000000C4090000146B4E000007724E000005C70900000A6F4E00000500000000000000000000000000000000000000006C4E000003734E000008C809000001000000000000000000000000000000000000000000000000006D4E000007744E000005C909000001714E0000056E4E0000030000000000CA09000001FC0800000AFD0800000AFE080000050000000000020900000500000000000000000000000000000000000000000309000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060900000A0000000000600900000A6109000009620900000100000000006609000005000000000000000000000000000000000000000067090000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006A090000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000195AF6050600000000000000000000000000000000000000000000000000000000000000000000004531F7000C", len);//00323031362D30322D31332030393A34343A32380000323031362D30322D31332030393A34343A32390000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030303030303030303030303030003030303030303020202030202020203020202030202020302020302000303000000020200000002020202070300000000000000000000000000000000000000010003000000000000000000000000000000000000000000010000000000000000000000000000000000020202000A0000000000000100000000030000000000000000000000000000000000000000000000000000000000000000000000000003000202090502020202020202010202020002020000020201030303030303000300000000000000000303030300000000000000030000000000000003030003030003000303030003000300030300000000000300000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000302020202020202020202020202010202020202020400000000000000000000000000000203010300000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000202020202020202020202020202020202020202020202020202020202020202020200000000000002020300030202020000130000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020202010202010104000000000000000000000000000000000003000000000000000000030300000000010101010101010301010101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000100000000020202020102020200000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000170067000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000840000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001000000000000000000000000000000000000000000000000000000000000000000000000000000000047010000040000000000000000000000000000000000000000000000000000000000000000000000000000000000580100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000C0200000100000000000000000000000000000000000000000000000000000000000000000000000000000000000F02000001000A0000000000000000000000000000000000000000000000000000000000000000000000000000001002000001000000000000000000000000000000000000000000000000000000000000000000000000000000000033020000010024000000FB0000001A01000000000000000000000000000000000000000000000000000000000000340200000100D9010000090000000D00000000000000000000000000000000000000000000000000000000000000350200000100270000000000000000000000000000000000000000000000000000000000000000000000000000003602000001001B0000000600000000000000000000000000000000000000000000000000000000000000000000003702000001000A00000001000000000000000000000000000000000000000000000000000000000000000000000038020000010000000000020000000000000000000000000000000000000000000000000000000000000000000000390200000100000000000800000000000000000000000000000000000000000000000000000000000000000000003B0200000100000000001300000000000000000000000000000000000000000000000000000000000000000000003C02000001001A0000000C00000000000000000000000000000000000000000000000000000000000000000000003D0200000100000000000400000000000000000000000000000000000000000000000000000000000000000000003E020000010000000000040000000000000000000000000000000000000000000000000000000000000000000000200300000100000000000000000000000000000000000000000000000000000000000000000000000000000000002A030000010000000000000000000000000000000000000000000000000000000000000000000000000000000000330300000100000000000000000000000000000000000000000000000000000000000000000000000000000000003A03000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;

	SendMyInfo();

	if (GetMapInstance() == NULL)
		//Make fail packet.
		return;

	//Check zone change.

	//result.Initialize(0x72);
	//arr = HEXSTRTOBYTEARR2("0cbe0132303035b3e22031bff9203235c0cf20bfb5bff520bfc2b6f3c0ce20bfc0c7c220baa3c5b8b8a620bdc3c0dbc0b8b7ce0ac1f6b1ddb1eec1f620bfb5bff520bfc2b6f3c0cec0bb20bbe7b6fbc7d8c1d6bdc520c8b8bff8b4d4b5e9b2b220c1f8bdc9c0b8b7ce20b0a8bbe7b5e5b8b3b4cfb4d92e0a0abed5c0b8b7ceb4c220c1f6b1ddb1eec1f6bab8b4d920b4f5bfed20c0e7b9ccc0d6b4c220bfb5bff520bfc2b6f3c0cec0cc20b5c7b5b5b7cf20c8b8bff8b4d4b5e9c0c720b8bbbeb8bfa120b1cdb8a620b1e2bfefc0ccb8e720c3d6b0edc0c720b9abc7f920b0d4c0d3c0b8b7ce20b0c5b5ec20c5c2beeeb3aab1e2b8a620bee0bcd3b5e5b8aeb8e720c0fac8f1b0a120c1d8baf1c7d120c0ccb9f82033c1d6b3e220c3e0c1a620b1e2b0a3c0ba20b8b6c0bdb2af20c1f1b0dcc1d6bdc3b1e220b9d9b6f8b4cfb4d92e0a0abfa9b7af20b0a1c1f6c0c720c0ccbaa5c6aeb4c220c8a8c6e4c0ccc1f6bfa1bcad20c8aec0cec0cc20b0a1b4c9c7cfbdc3b8e70ab1c3b1ddc7cfbdc520bbe7c7d7bfa120b4ebc7d8bcadb4c220bef0c1a6b5e7c1f620b8bbbeb8c1d6bdc3b8e920bcbabdc9bcbac0c7b2af20becbb7c1b5e5b8aeb0dabdc0b4cfb4d92eff015072656d69756d20504320436166652042656e6566697420496e666f726d6174696f6e0a312920496e637265617365204558502033302520666f72206d6f6e737465722068756e74696e670a322920496e63726561736520746865206368616e636520746f2067657420746865205065742032302520666f72206d6f6e737465722068756e74696e670a332920496e63726561736520536b696c6c2f4e6f726d616c204445462035250a342920496e637261736520536b696c6c2f4e6f726d616c204154544b2034250a35292052616e646f6d20426f7820666f722050432043616665206f6e6c790a362920496e76656e746f727920666f722050432043616665206f6e6c790a3729204669656c647320666f722050432043616665206f6e6c790a2d2048656c6c2056656e6f6d2043616e796f6e0a2d20476c616369616c2053756d6d69740a2d2044657365727465642054656d706c650a2d2052656420447261676f6e2773204c6169720a2d205768697465205761746572204f617369730a382920496e637265617365204154544b205370706564203330250aa1d820455850284368617261637465722f53706972697473292062656e6566697473206170706c792077697468207072656d696d206974656d732c20627574206f74686572206f7074696f6e732063616e6e6f74206265206475706c6963617465642e00", len);
	//for (int i = 0; i < len; i++)
	//	result << arr[i];

	//delete[] arr;

	//Send(&result);

	//result.Initialize(0x2B);
	//result << uint8(0x01);
	//Send(&result);

	//result.Initialize(0xcc);
	//arr = HEXSTRTOBYTEARR2("01030000fd08000003010052040000000c003fc2a100000f003ec2a100030400510400000305000609000003060054040000030700530400000308004f04000003090050040000030a00c7090000030b0003090000030c000209000000000000000000030e006f4e0000030f004c040000031000fe08000003110055040000031200c4090000031300fc0800000314006e4e00000315006d4e0000031600734e0000031700724e00000318004d0400000319004e040000031a006b4e0000031b006c4e0000031c00714e0000031d00744e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", len);
	//for (int i = 0; i < len; i++)
	//	result << arr[i];

	//delete[] arr;

	//Send(&result);

	result.Initialize(0x24);
	//00004c42 x 332e2543 z
	result << m_userData->m_curPosX << m_userData->m_curPosZ;

	Send(&result);

	SendUnk75();

	SendCharacterUpdate();
	
	SendUpdateHpAndChi(NULL);

	result.Initialize(0x72);
	arr = HEXSTRTOBYTEARR2("0100", len);
	foreach_array_n(i, arr, len)
		result << arr[i];
	delete[] arr;
	//0A 4461726b6e6573732034
	result << m_curServerInstance->m_serverInfo->m_serverName;
	arr = HEXSTRTOBYTEARR2("030d0004000c000c00240018000000070003000200", len);
	foreach_array_n(i, arr, len)
		result << arr[i];
	delete[] arr;
	Send(&result);

	//result.Initialize(0x51);
	//arr = HEXSTRTOBYTEARR2("060a0000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);

	//7500010080a14300003d43
	//14970000000100000000000000e700000000001c69027a36000000201c0000002af5e67c360000009600c00014003e00ab03cb0300001f0000001f00c800e700009a99294166668641fb03000000402d2f0000dc130000d20a930d5e0e00005e0e00005e0e00009dc4000011f60000dd2900004b01100105000000a5000016008800000000b6000000000000000000005e0e0000dd29000000ffff303130392d30362d31392031323a30303a30300039302e3232372e3139332e363000000000000000040000000064007c02000087020000a00000000000803f0000803f
	//51080a000e07c000c0003f010000f2020000
	//51080a000e07c000c0003f010000f2020000

	/*result.Initialize(0xAD);
	result << uint8(0x01);
	Send(&result);*/
	//7500010080a14300003d43
	//14970000000100000000000000e700000000001c69027a36000000201c0000002af5e67c360000009600c00014003e00ab03cb0300001f0000001f00c800e700009a99294166668641fb03000000402d2f0000dc130000d20a930d5e0e00005e0e00005e0e00009dc4000011f60000dd2900004b01100105000000a5000016008800000000b6000000000000000000005e0e0000dd29000000ffff003130392d30362d31392031323a30303a30300039302e3232372e3139332e363000000000000000040000000064007c02000087020000a00000000000803f0000803f
	//aa55de0055aa idk what the fuck this is

	result.Initialize(0x4F);
	result << uint16(0x0000);
	Send(&result);

	//result.Initialize(0x21);
	//arr = HEXSTRTOBYTEARR2("012403d90d0000040100000006536974616d6197000000451f0200201c00000000004c42332e25432046c74100004c42332e25432046c74100000000ffff1b2b0000c80000002d2f0000000000000003fb03000000050000000032000000454400000011000000010000000064ffffffff07e6120b013301a60000000000b50fcb013401a20600000000e8120b013501a60000000000dcb7ef000300a40600000000238a09010400a40400000000e7120b013601a60000000000000000000a00000000000000000000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	//7500010080a14300003d43
	//14970000000100000000000000e700000000001c69027a36000000201c0000002af5e67c360000009600c00014003e00ab03cb0300001f0000001f00c800e700009a99294166668641fb03000000402d2f0000dc130000d20a930d5e0e00005e0e00005e0e00009dc4000011f60000dd2900004b01100105000000a5000016008800000000b6000000000000000000005e0e0000dd29000000ffff003130392d30362d31392031323a30303a30300039302e3232372e3139332e363000000000000000040000000064007c02000087020000a00000000000803f0000803f
	//16240324032d2f0000a2120000000000000000000000000000000000000000000000000032000000
	//7201000a4461726b6e6573732034030d0004000c000c00240018000000070003000200
	//51060a0000
	//7500010080a14300003d43
	//14970000000100000000000000e700000000001c69027a36000000201c0000002af5e67c360000009600c00014003e00ab03cb0300001f0000001f00c800e700009a99294166668641fb03000000402d2f0000dc130000d20a930d5e0e00005e0e00005e0e00009dc4000011f60000dd2900004b01100105000000a5000016008800000000b6000000000000000000005e0e0000dd29000000ffff003130392d30362d31392031323a30303a30300039302e3232372e3139332e363000000000000000040000000064007c02000087020000a00000000000803f0000803f
	//51080a000e07c000c0003f010000f2020000
	//51080a000e07c000c0003f010000f2020000
	//ad01
	//result.Initialize(0x83);
	//arr = HEXSTRTOBYTEARR2("0844000000d90d000006536974616d6197000000011b2b0000c800000050c30000451f0103000000130000000000000000000000000a323031362d30352d3132244368696e65736520476f6c64204661726d65722c20416c776179732073656d692d61666b", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	////aa55660055aa another weird one
	//result.Initialize(0x8A);
	//arr = HEXSTRTOBYTEARR2("0700d90d000006536974616d6102970000000100000000000000000000000000de6b000001054775696c74550000000100020f00000208526f766b6c616464520000001200000000000300000000000000000000000400000000000000000000000500000000000000000000000600000000000000000000000700000000000000000000000800000000000000000000000900000000000000000000000a00000000000000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);

	//result.Initialize(0xcb);
	//arr = HEXSTRTOBYTEARR2("011cf30d00000441616e670000020f000008526f766b6c6164640000c81300000554657a7a6900001356000006687472646a740100380f00000977696e64646576696c0000703300000653756c7a657200002c16000009426c6f6f647963756e0000ed1e0000045768616e0000805500000c53616e7461476f4372617a790000470f0000044d6f6f6e0000aa3000000c486967684c6f726447657461000093650000086d6f7274616c6973000081200000084b616e6e696b61720000ff460000064e6f726d61690000eb5600000a4461694c61694c616d6100004a4a000007416e74687261780000de6b0000054775696c740000ea6700000856697669656e6e650000e04d000008536f6e696346346e00001d5600000a78584d65726c696e58780000366400000878526f73617269610000117200000652656e6761720000181d0000087858416d657258780100595c00000d42626f7947616e6773746162720100565a00000d6c6c4c616479426c6164656c6c0100a03300000e4765744f757446726f6d486572650000d84100000941414142424261584501008c85000007536b696c6c6574000000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);


	//aa55ab0155aa Again idk, realy
	//result.Initialize(0xcb);
	//arr = HEXSTRTOBYTEARR2("021d560000010100", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	//aa55090055aa idk..
	//aa55090055aa
	//830844000000d90d000006536974616d6197000000011b2b0000c800000050c30000451f0103000000130000000000000000000000000a323031362d30352d3132244368696e65736520476f6c64204661726d65722c20416c776179732073656d692d61666b
	//aa55660055aa
	//8a0700d90d000006536974616d6102970000000100000000000000000000000000de6b000001054775696c74550000000100020f00000208526f766b6c616464520000001200000000000300000000000000000000000400000000000000000000000500000000000000000000000600000000000000000000000700000000000000000000000800000000000000000000000900000000000000000000000a00000000000000
	//char level notice, and the 2nd Below is basicly character blink.
	SendNotice(GetLevelString());

	//This is the first blink thing
	//result.Initialize(0x71, MT_PLAYER_NOTICE);
	//arr = HEXSTRTOBYTEARR2("2a4368617261637465722077696c6c2062652061637469766174656420696e203330207365636f6e64732e", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	//aa552d0055aa

	//7500010080a14300003d43
	//aa550b0055aa
	//Different char stats packet etc, idk but it's fucked, maybe another version?
	//result.Initialize(0x14);
	//arr = HEXSTRTOBYTEARR2("970000000100000000000000e700000000001c69027a36000000201c0000002af5e67c360000009600c00014003e00ab03cb030000bc5ff44cda2b9c97266dd1fc08004508027cf4a640002c06f9d23408680ac0a801403ab9d2de4d083d1afe4eceb85018369adc3300001f0000001f00c800e700009a99294166668641fb03000000402d2f0000dc130000d20a930d5e0e00005e0e00005e0e00009dc4000011f60000dd2900004b01100105000000a5000016008800000000b6000000000000000000005e0e0000dd29000000ffff003130392d30362d31392031323a30303a30300039302e3232372e3139332e363000000000000000040000000064007c02000087020000a00000000000803f0000803f", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	//16240324032d2f0000a2120000000000000000000000000000000000000000000000000032000000
	//result.Initialize(0x4D);
	//arr = HEXSTRTOBYTEARR2("0145000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);
	////aa55530155aa idk, length of last packet or some shit
	//result.Initialize(0x2F);
	//arr = HEXSTRTOBYTEARR2("f12403320000004", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);

	//result.Initialize(0x2F);
	//arr = HEXSTRTOBYTEARR2("f200", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);

	//result.Initialize(0x01);
	//arr = HEXSTRTOBYTEARR2("b90a0001", len);
	//foreach_array_n(i, arr, len)
	//	result << arr[i];
	//delete[] arr;
	//Send(&result);

	//Activate character. Should be it's own function or smth, Send activate char or w/e
	/*result.Initialize(0x7108);
	result << "Character has been activated.";
	Send(&result);*/
	m_state = GAME_STATE_INGAME;

	SetRegion(GetNewRegionX(), GetNewRegionZ());
	GetMapInstance()->AddUser(this);
	UserLeaveEnterRegion(1);
	GetMapInstance()->RegionUserInfoToMe(this);
	GetMapInstance()->RegionNpcInfoToMe(this);

	SendGlobalNotice(string_format("User %s has entered the world. MAP: %d X: %.1f Z: %.1f Y: %.1f", GetName(), m_userData->m_zone, GetX(), GetZ(), GetY()));

	BlinkStart();
}

void CUser::Update(uint32 diff)
{
	if (IsBlinking())
		UpdateBlinkTime(diff);

	if (IsMeditating())
		HandleMeditating(diff);

	//TODO: Check for expired items and stuff
}

void CUser::BlinkStart()
{
	//TODO: Don't blink in warzones.

	m_abnormalType = ABNORMAL_BLINKING;
	m_blinkTimer.Reset(1000);
	m_blinkCount = 31;//30 seconds.

	//TODO: Set invisbilty type for monsters
}

void CUser::UpdateBlinkTime(uint32 diff)
{
	if (m_blinkTimer.Passed())
		return;

	m_blinkTimer.Update(diff);
	if (m_blinkTimer.Passed() && m_blinkCount > 0)
	{
		SendNotice(string_format("Character will be activated in %d second(s).", m_blinkCount - 1));
		m_blinkCount--;
		m_blinkTimer.Reset(1000);
		return;
	}
	else if (m_blinkCount > 0)
		return;

	m_abnormalType = ABNORMAL_NORMAL;
	SendRegionCharacterUpdate();
	SendNotice("Character has been activated.");
}

void CUser::HandleCharacterMovement(Packet& pkt)
{
	if (IsDead())
		return;
	if (IsBlinking())
	{
		m_blinkCount = 0;
		UpdateBlinkTime(0);//Maybe i should just let the main loop handle this.
	}

	//if (IsMeditating())
		//ToggleMeditation();
	Packet result(PKT_GAMESERVER_CHARACTER_MOVE);

	uint8 unk;
	float cur_x, cur_z, cur_y, will_x, will_z, will_y, old_x, old_z;
	pkt >> unk >> cur_x >> cur_z >> cur_y >> will_x >> will_z >> will_y;
	old_x = m_userData->m_curPosX;
	old_z = m_userData->m_curPosZ;
	m_userData->m_curPosX = will_x;
	m_userData->m_curPosZ = will_z;
	m_userData->m_curPosY = will_y;

	if (RegisterRegion())
	{
		//TODO: I'd like to rewrite all this code into OnRegionExit(oldRX old RZ), OnRegionEnter(nRX, nRZ) and in there we call everything that should happen on enter/exit.
		//Get Nearby users and npcs
		GetMapInstance()->RegionUserInfoToMe(this);
		GetMapInstance()->RegionNpcInfoToMe(this);
		GetMapInstance()->RegionItemInfoToMe(this);
	}

	result << GetID();
	result << uint8(0x01);//Unk, was 01 for me, 02 for wind
	result << cur_x << cur_z << cur_y;
	result << will_x << will_z << will_y;
	result << m_movementSpeed;//Speed?
	result << uint16(0x0000);//End thing?

	//SERVER_INSTANCE_CHANGE
	SendToRegion(result, NULL);
	//g_main->SendToRegion(result, GetMap(), GetRegionX(), GetRegionZ(), NULL);
}

void CUser::HandleNpcGossip(Packet& pkt)
{
	uint8 subOpcode;
	uint16 npcId;
	uint32 option;
	pkt >> subOpcode;

	CNpc* pNpc = NULL;

	switch (subOpcode)
	{
		case 1:
			pkt >> npcId;

			pNpc = GetMapInstance()->GetNpcPtr(npcId);
			m_currentGossip = pNpc;

			if (pNpc == NULL || pNpc->IsMonster() || pNpc->DistanceToTarget(this) > 13.0f)
				return;

			SendNpcGossip(pNpc);
			break;
			//User chose an option in the menu
		case 2:
		{
			pkt >> option;
			GossipFlag gossipFlag;
			_GOSSIP_OPTION* pGossipOption = sObjMgr->GetGossipOptionInfo(option);
			//If there's no definition for it, asssume we're dealing with a new window
			if (pGossipOption == NULL)
				gossipFlag = GOSSIP_FLAG_NEW_GOSSIP_TABLE;
			else
				gossipFlag = pGossipOption->gossipFlag;

			switch (gossipFlag)
			{
			case GOSSIP_FLAG_OPEN_NPC_TRADE:
			{
				_SHOP_TABLE* pShop = sObjMgr->GetShopTableInfo(option);
				SendOpenNpcExchange(pShop);
				break;
			}
			case GOSSIP_FLAG_OPEN_BANK:
				SendOpenBank();
				break;
			case GOSSIP_FLAG_GOTO:
				if (m_userData->m_gold < pGossipOption->goldCost)
					return;//TODO: Make error message.

				if(pGossipOption->goldCost > 0)
					GoldChange(-pGossipOption->goldCost);

				if (pGossipOption->toZone == 14 && m_userData->m_faction != 1)
					ChangeZone(sObjMgr->GetZoneStartPosition(15));//Special handling for faction districts. TODO: Might want to add a specific value in the table for these occurances.
				else
					ChangeZone(sObjMgr->GetZoneStartPosition(pGossipOption->toZone));
				break;
			case GOSSIP_FLAG_OPEN_WORLDMAP_TELEPORTER:
				SendOpenWorldMapTeleporter();
				break;
			case GOSSIP_FLAG_OPEN_STRENGTHEN:
				OpenStrengtheningWindow();
				break;
			case GOSSIP_FLAG_OPEN_COMPOSITION:
				OpenCompositionWindow();
				break;
			case GOSSIP_FLAG_OPEN_EXTRACTION:
				OpenExtractionWindow();
				break;
			case GOSSIP_FLAG_OPEN_DISMANTLE:
				OpenDismantleWindow();
				break;
			case GOSSIP_FLAG_OPEN_ADVANCE_FUSION:
				OpenAdvancedFusionWindow();
				break;
			default:
				SendNpcGossip(option);
				break;
			}
			break;
		}
		default:
			break;
	}
}

void CUser::SendNpcGossip(uint32 gossipId)
{
	_NPC_GOSSIP* pGossip = sObjMgr->GetNpcGossipInfo(gossipId);

	if (pGossip == NULL)
		return;

	Packet result(PKT_GAMESERVER_ADD_ITEM_CONTINUOS, uint8(2));
	result << pGossip->npcId
		<< pGossip->npcSayId
		<< pGossip->optionCount;

	for (int i = 0; i < pGossip->optionCount; i++)
	{
		result << pGossip->option[i]
			<< pGossip->response[i];
	}

	Send(&result);
}

void CUser::SendNpcGossip(CNpc* pNpc)
{
	_NPC_GOSSIP* pGossip = sObjMgr->GetNpcGossipInfo(sObjMgr->GetNpcInfo(pNpc->GetNpcID())->m_gossipId);

	if (pGossip == NULL)
		return;

	Packet result(PKT_GAMESERVER_ADD_ITEM_CONTINUOS, uint8(2));
	result << pGossip->npcId
		<< pGossip->npcSayId
		<< pGossip->optionCount;

	for (int i = 0; i < pGossip->optionCount; i++)
	{
		result << pGossip->option[i]
			<< pGossip->response[i];
	}

	Send(&result);
}

void CUser::SendOpenNpcExchange(_SHOP_TABLE* pShop)
{
	if (pShop == NULL)
		return;

	Packet result(PKT_GAMESERVER_ADD_ITEM_CONTINUOS, uint8(3));
	result << uint8(1)
		<< pShop->shopId;

	Send(&result);
}

void CUser::SendOpenWorldMapTeleporter()
{
	Packet result(PKT_GAMESERVER_WORLD_MAP_TELEPORTER, uint8(1));
	result << uint8(1);

	Send(&result);
}

void CUser::HandleWorldMapTeleporter(Packet & pkt)
{
	uint8 subOpcode, zone;
	pkt >> subOpcode >> zone;

	//TOOD: Handle travel cost.
	_ZONESTART_POSITION* pZone = sObjMgr->GetZoneStartPosition(zone);

	if (pZone == NULL)
		return;

	ChangeZone(pZone);
}

void CUser::HandleNpcConvoTesting(Packet& pkt)
{
	uint8 subOpcode;
	pkt >> subOpcode;
	Packet result;

	switch (subOpcode)
	{
	case 1:
		//Incoming packet contains the unique NPC id and 2 unk end bytes(Allways 00 00 so far).
		result.Initialize(PKT_GAMESERVER_ADD_ITEM_CONTINUOS, uint8(2));
		result << uint32(0x00004F70) //NpcId
			<< uint32(0x3C6F0A09) //What he says, from npcscript
			<< uint8(5) //Amount of options?
			<< uint32(1) //His talk options(Exhange in this case)
			<< uint32(0x4FA1BE01)
			<< uint32(2)
			<< uint32(0x4FA1BE01)
			<< uint32(3)
			<< uint32(0x4FA1BE01)
			<< uint32(4)
			<< uint32(0x4FA1BE01)
			<< uint32(5)
			<< uint32(0x4FA1BE01); //This is his 28:6 id in the npcTable, this is the response he's supposed to give.
		break;
	case 2:
		result.Initialize(PKT_GAMESERVER_ADD_ITEM_CONTINUOS, uint8(3));
		result << uint8(1)
			<< uint16(26)
			<< uint8(0)
			<< uint8(0);
		break;
	default:
		printf("Unkown npc conversation subopcode: %d", subOpcode);
		break;
	}
	

	Send(&result);
}

void CUser::RemoveOldPlayersInVision(int x, int z)
{
	if (x != 0)
	{
		RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x * 2, GetRegionZ() + z - 1));
		RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x * 2, GetRegionZ() + z));
		RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x * 2, GetRegionZ() + z + 1));
	}

	if (z != 0)
	{
		RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x, GetRegionZ() + z * 2));
		if (x < 0)
			RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x + 1, GetRegionZ() + z * 2));
		else if (x > 0)
			RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x - 1, GetRegionZ() + z * 2));
		else
		{
			RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x - 1, GetRegionZ() + z * 2));
			RemovePlayersOutsideOfVision(GetMapInstance()->GetRegion(GetRegionX() + x + 1, GetRegionZ() + z * 2));
		}
	}
}

void CUser::RemovePlayersOutsideOfVision(Region* pRegion)
{
	if (pRegion == NULL)
		return;
	
	auto m = pRegion->m_regionUserMap.m_UserTypeMap;
	foreach(user, m)
	{
		CUser* pUser = g_main->GetUserPtr(user->first);
		if (pUser == NULL)
			continue;
		Packet result;

		pUser->GetInOut(result, 2);
		Send(&result);
	}
}

void CUser::HandleZoneChange(Packet& pkt)
{
	if (IsDead())
		return;

	uint32 zoneChangeId;
	pkt >> zoneChangeId;

	_ZONECHANGE_DATA* pZoneChange = sObjMgr->GetZoneChangeData(zoneChangeId);

	//TODO: Figure out how to break the "PLEASE WAIT" thing, error or w/e. Simply do it on the real server and look what they send.
	if (pZoneChange == NULL)
	{
		Packet result(PKT_GAMESERVER_ZONE_CHANGE);
		result << uint8(-1);
		result << uint16(0);
		result << uint8(0);
		Send(&result);
		return;
	}

	ChangeZone(pZoneChange);
}

void CUser::SendToServerInstance(Packet& pkt, CUser* pExceptUser)
{
	m_curServerInstance->SendToAll(pkt);
}

bool CUser::GoToXZ(uint16 posX, uint16 posZ)
{
	if (posX > GetMapInstance()->GetMap()->m_sizeMap.cx || posZ > GetMapInstance()->GetMap()->m_sizeMap.cy)
		return false;

	UserLeaveEnterRegion(2);
	m_userData->m_curPosX = posX;
	m_userData->m_curPosZ = posZ;
	
	Packet result(PKT_GAMESERVER_CHARACTER_TELEPORT);
	result << m_userData->m_curPosX;
	result << m_userData->m_curPosZ;
	Send(&result);
	UserLeaveEnterRegion(1);
	return true;
}

void CUser::ChangeZone(_ZONECHANGE_DATA* pZone)
{
	//TODO: Checks for battlegrounds needed.
	if (GetLevel() < pZone->m_reqLevel)
		return;

	uint16 oldZone = m_userData->m_zone;
	float oldX = m_userData->m_curPosX,
		oldZ = m_userData->m_curPosZ;

	UserLeaveEnterRegion(2);
	m_userData->m_zone = pZone->m_toZoneId;
	m_userData->m_curPosX = pZone->m_posX;
	m_userData->m_curPosZ = pZone->m_posZ;

	GetMapInstance()->RemoveUser(this);

	m_curMapInstance = m_curServerInstance->GetMapInstanceByZoneId(m_userData->m_zone);
	if (GetMapInstance() == NULL)
	{
		m_curMapInstance = m_curServerInstance->GetMapInstanceByZoneId(oldZone);
		m_userData->m_zone = oldZone;
		m_userData->m_curPosX = oldX;
		m_userData->m_curPosZ = oldZ;
		printf("User %s attempted to enter a non existing map.", m_userData->m_charId);
		return;
	}

	SetRegion(GetNewRegionX(), GetNewRegionZ());
	GetMapInstance()->AddUser(this);

	Packet result(PKT_GAMESERVER_CHANGE_CLIENT_ZONE);
	result << pZone->m_toZoneId;
	result << pZone->m_posX;
	result << pZone->m_posZ;
	result << float(1000);
	Send(&result);

	result.Initialize(PKT_GAMESERVER_CHARACTER_TELEPORT);
	result << m_userData->m_curPosX;
	result << m_userData->m_curPosZ;
	Send(&result);

	result.Initialize(PKT_GAMESERVER_UPDATE_ZONE);
	result << pZone->m_toZoneId << uint8(0);
	Send(&result);

	result.Initialize(0xAD, uint8(1));//TODO: Idk what this does.
	Send(&result);

	//TODO: Add merchant etc
	GetMapInstance()->RegionUserInfoToMe(this);
	GetMapInstance()->RegionNpcInfoToMe(this);

	UserLeaveEnterRegion(1);
}

void CUser::ChangeZone(_ZONESTART_POSITION* pZone)
{
	_ZONECHANGE_DATA* pChange = sObjMgr->GetZoneChangeData(pZone->m_zoneId);

	_ZONECHANGE_DATA* pZoneChange = new _ZONECHANGE_DATA();
	pZoneChange->m_toZoneId = pZone->m_zoneId;
	pZoneChange->m_posX = pZone->m_x;
	pZoneChange->m_posZ = pZone->m_z;

	if (pChange == NULL)
		pZoneChange->m_reqLevel = 0;
	else
		pZoneChange->m_reqLevel = pChange->m_reqLevel;

	ChangeZone(pZoneChange);
	delete pZoneChange;
}

void CUser::HandleMeditating(uint32 diff)
{
	m_meditationTimer.Update(diff);
	if (m_meditationTimer.Passed())
	{
		HpChange(20 + m_maxHp * 0.05f);
		ChiChange(20 + m_maxChi * 0.05f);
		m_meditationTimer.Reset(MEDITATION_TICK);
	}
}

void CUser::GetInOut(Packet& result, uint8 inOutType)
{
	result.Initialize(PKT_GAMESERVER_REGION_CHANGE_USER, uint8(inOutType));
	//result << GetID();
	if (inOutType != 2)//exit
		result.append(GetUserInfoForRegion());
	else
		result << GetID() << uint8(0);
}

void CUser::UserLeaveEnterRegion(uint8 type)
{
	if (GetRegion() == NULL)
		return;

	Packet result;
	GetInOut(result, type);

	if (type == 2)
		GetRegion()->Remove(this);
	else
		GetRegion()->Add(this);

	//SERVER_INSTANCE_CHANGE
	SendToRegion(result, NULL);
	//g_main->SendToRegion(result, GetMap(), GetRegionX(), GetRegionZ(), NULL);
}

void CUser::HandleChangeCombatState(Packet& pkt)
{
	if (IsMeditating())
		return;
	bool cState;
	pkt >> cState;
	ToggleCombatState();
	Packet result(PKT_GAMESERVER_CHANGE_COMBAT_STATE);
	result << GetID() << IsInCombateState();
	//SERVER_INSTANCE_CHANGE
	SendToRegion(pkt, NULL);
	//g_main->SendToRegion(pkt, GetMap(), GetRegionX(), GetRegionZ(), NULL);
}

void CUser::HandleMeditation(Packet& pkt)
{
	if (IsInCombateState())
		return;
	uint8 unk;
	bool toState;
	pkt >> unk >> toState;
	ToggleMeditation();//TODO: this might impact thread things? If it changes while the main thread is reading it.

	Packet result(PKT_GAMESERVER_MEDITATE, uint8(0x05));//unk magic number, w/e
	result << GetID() << IsMeditating();
	//SERVER_INSTANCE_CHANGE
	SendToRegion(pkt, NULL);
	//g_main->SendToRegion(pkt, GetMap(), GetRegionX(), GetRegionZ(), NULL);
}

void CUser::HandleAddStatPt(Packet& pkt)
{
	uint8 stat;
	uint16 amount;
	pkt >> stat >> amount;

	if (stat > STAT_FIRE)
		return;

	if (stat < STAT_WIND)
	{
		if (amount > GetFreeStatPoints())
			return;

		m_userData->m_stats[stat] += amount;
	}
	else
	{
		if (amount > GetFreeElementPoints())
			return;

		m_userData->m_stats[stat] += amount;
	}

	UpdateUserStats();

	SendCharacterUpdate();
	UserLeaveEnterRegion(1);
}

//TODO: Make it possible to store a Unit target instead;
void CUser::HandleTargetChange(Packet & pkt)
{
	uint16 targetId;
	pkt >> targetId;

	CUser* newTarget = g_main->GetUserPtr(targetId);
	//If there was no new target, default to self, to make sure the user knows who he's actualy targetting.
	if (newTarget == NULL)
		newTarget = this;

	m_target = newTarget;
}

void CUser::GoldChange(int amount, bool updateClient /*= true*/)
{
	if (amount == 0)
		return;

	if (amount < 0 && -amount > m_userData->m_gold)
		m_userData->m_gold = 0;
	else if (amount >= 0 && m_userData->m_gold + amount > MAX_GOLD)
		m_userData->m_gold = MAX_GOLD;
	else
		m_userData->m_gold += amount;

	if (updateClient)
		SendGoldUpdate();
}
//TODO: These functions. Not good, the fact that they're the same in both npc and player, that the send update in each...
void CUser::HpChange(int amount, Unit * pAttacker, uint32 skillId /*= 0*/)
{
	if (amount < 0 && -amount > m_userData->m_curHp)
		m_userData->m_curHp = 0;
	else if (amount >= 0 && m_userData->m_curHp + amount > m_maxHp)
		m_userData->m_curHp = m_maxHp;
	else
		m_userData->m_curHp += amount;

	SendUpdateHpAndChi(pAttacker);
}

void CUser::ChiChange(int amount)
{
	if (amount < 0 && -amount > m_userData->m_curChi)
		m_userData->m_curChi = 0;
	else if (amount >= 0 && m_userData->m_curChi + amount > m_maxChi)
		m_userData->m_curChi = m_maxChi;
	else
		m_userData->m_curChi += amount;

	SendUpdateHpAndChi(NULL);
}

void CUser::OnDeath(Unit * pKiller)
{

}

uint16 CUser::GetFreeStatPoints()
{
	int16 pts = g_main->GetStatPointsByLevel(GetLevel()) - GetTotalSpentStatPoints();
	if (pts <= 0)
		return uint16(0x0000);
	else
		return uint16(pts);
}

uint32 CUser::GetTotalSpentStatPoints()
{
	_CHARACTER_DATA* pChar = sObjMgr->GetCharacterInfo(m_userData->m_charType);
	uint16 str = m_userData->m_stats[STAT_STR] - pChar->m_baseStr, dex = m_userData->m_stats[STAT_DEX] - pChar->m_baseDex, inte = m_userData->m_stats[STAT_INT] - pChar->m_baseInt;

	return str + dex + inte;
}

uint16 CUser::GetFreeElementPoints()
{
	if (GetLevel() < 101)
		return 0;

	uint16 freePts = g_main->GetElementPointsByLevel(GetLevel()) - GetTotalSpentElementPoints();
	if (freePts > 0)
		return freePts;
	else
		return 0;
}

uint32 CUser::GetTotalSpentElementPoints()
{
	uint16 wind = m_userData->m_stats[STAT_WIND], water = m_userData->m_stats[STAT_WATER], fire = m_userData->m_stats[STAT_FIRE];

	return wind + water + fire;
}
//TODO: Actualy make this something, just random value atm.
uint32 CUser::GetTotalSkillPoints()
{
	return (GetLevel() + (GetLevel() * pow(1.02f, GetLevel())));
}

uint32 CUser::GetLevel()
{
	return m_userData->m_level;
}

void CUser::UpdateItemSlotValues()
{
	_ITEM_TABLE* pTable = NULL;
	ResetItemSlotValues();
	m_activeSetBonuses.clear();

	//TODO: Ignoring pet items, we shouldn't do that in the future, add variables to store this.
	for (int i = 0; i < IS_END; i++)//Ignore pet(slot 10)
	{
		if (!IsEquipSlot(i))
			continue;

		_ITEM_DATA* pItem = &m_userData->m_itemArray[i];
		if (pItem->itemId == 0)
			continue;

		pTable = sObjMgr->GetItemTemplate(pItem->itemId);
		if (!pTable)
			continue;

		//Only count active weapon.
		if (i == IS_WEAPON1 || i == IS_WEAPON2)
			if (i != m_userData->m_activeWeapon)
				continue;
			else
			{
				m_itemDelay = pTable->m_delay;
				m_itemAttackRange = pTable->m_attackRange;
				m_itemAttackAoE = pTable->m_attackAoE;
			}

		//Set stats from item.
		SetItemStats(pTable);

		//Set stats from upgrades
		for (int j = 0; j < pItem->upgradeCount; j++)
			SetItemStats(sObjMgr->GetItemTemplate(pItem->upgrades[j]));

		//stats from holes.
		for (int j = 0; j < pItem->holeCount; j++)
			SetItemStats(sObjMgr->GetItemTemplate(pItem->holes[j]));

		//TODO: I think a class should handle this
		//Store active set bonuses
		if (pTable->m_setBonus != nullptr)
		{
			auto cSet = m_activeSetBonuses.find(pTable->m_setBonus->m_setId);
			if (cSet != m_activeSetBonuses.end())
				cSet->second++;
			else
				m_activeSetBonuses.insert(make_pair(pTable->m_setBonus->m_setId, 1));
		}
		//TODO: Implement buff type items things.
	}

	//Loop over all active sets and add them.
	for (auto cSet : m_activeSetBonuses)
	{
		_SET_BONUS* pBonusTemplate = sObjMgr->GetSetBonus(cSet.first);
		if (pBonusTemplate->MeetsBonusRequirement(cSet.second))
		{
			_ITEM_TABLE* pBonusTable = NULL;

			for (int i = 0; i < MAX_PARTIAL_SET_BONUS; i++)
			{
				pBonusTable = sObjMgr->GetItemTemplate(pBonusTemplate->GetPartialBonus(i));
				if (pBonusTable == NULL)
					continue;
				SetItemStats(pBonusTable);
			}
			pBonusTable = NULL;

			if (pBonusTemplate->MeetsExtraBonusRequirement(cSet.second))
			{
				for (int i = 0; i < MAX_EXTRA_PARTIAL_SET_BONUS; i++)
				{
					pBonusTable = sObjMgr->GetItemTemplate(pBonusTemplate->GetExtraPartialBonus(i));
					if (pBonusTable == NULL)
						continue;
					SetItemStats(pBonusTable);
				}
			}
		}
	}
}

//TODO: Implement this properly
uint32 CUser::GetDamage(Unit* pTarget)
{
	uint32 damage;

	if (pTarget == NULL || pTarget->IsDead())
		return 0;
	std::random_device r;
	std::mt19937 rng(r());
	std::uniform_int_distribution<uint32> gen(m_minDamage, m_maxDamage);

	damage = gen(rng);

	return damage;
}

//TODO: Implement this properly
uint32 CUser::GetSkillDamage(Unit * pTarget, _PLAYER_SKILL_DATA* pSkillUsed)
{
	uint32 damage;
	uint32 minDmg, maxDmg;

	if (pTarget == NULL || pTarget->IsDead())
		return 0;

	minDmg = m_minSkillDamage + pSkillUsed->m_pData->m_minDmg + pSkillUsed->m_pData->m_minDmgPerLevel * pSkillUsed->m_pointsSpent;
	maxDmg = m_maxSkillDamage + pSkillUsed->m_pData->m_maxDmg + pSkillUsed->m_pData->m_maxDmgPerLevel * pSkillUsed->m_pointsSpent;

	std::random_device r;
	std::mt19937 rng(r());
	std::uniform_int_distribution<uint32> gen(minDmg, maxDmg);

	damage = gen(rng);

	return damage;
}

void CUser::SetItemStats(_ITEM_TABLE* pTable)
{
	m_itemMinDmg += pTable->m_damageMin;
	m_itemMaxDmg += pTable->m_damageMax;
	m_itemMinBonusDmg += pTable->m_minBonusDamage;
	m_itemMaxBonusDmg += pTable->m_maxBonusDamage;
	m_itemBonusDmgPercent += pTable->m_damagePercent;
	m_itemMinBonusSDmg += pTable->m_minSkillDamageBonus;
	m_itemMaxBonusSDmg += pTable->m_maxSkillDamageBonus;
	m_itemBonusSDmgPercent += pTable->m_skillDamagePercent;
	m_itemDefense += pTable->m_defense + (pTable->m_headDefense / 3 + pTable->m_bodyDefense / 3 + pTable->m_footDefense / 3);
	m_itemDefensePercent += pTable->m_defensePercent;
	m_itemSDefense += pTable->m_artsDefense;
	m_itemSDefensePercent += pTable->m_artsDefensePercent;
	for (int k = 0; k < STAT_END; k++)
		m_itemStatBonus[k] += pTable->m_statBonus[k];
	m_itemPoisonDmg += pTable->m_poisonDamage;
	m_itemPoisonDef += pTable->m_poisonDefense;
	m_itemConfusionDmg += pTable->m_confusionDamage;
	m_itemConfusionDef += pTable->m_confusionDefense;
	m_itemParalysisDmg += pTable->m_paralysisDamage;
	m_itemParalysisDef += pTable->m_paralysisDefense;
	m_itemMaxHp += pTable->m_maxHp;
	m_itemHpRecoveryPercent += pTable->m_hpRecoveryPercent;
	m_itemMaxChi += pTable->m_maxChi;
	m_itemChiRecoveryPercent += pTable->m_chiRecoveryPercent;
	m_itemMovementSpeed += pTable->m_movementSpeed;
	m_itemAccuracy += pTable->m_accuracy;
	m_itemDodge += pTable->m_dodge;
	m_itemCritChance += pTable->m_critChance;
	m_itemBonusExp += pTable->m_bonusExp;
	m_itemDropBonus += pTable->m_itemDropBonus;
	m_itemBonusMineral += pTable->m_bonusMineral;
}

void CUser::UpdateHpChi()
{
	SendUpdateHpAndChi(NULL);
}

void CUser::UpdateUserStats()
{
	//TODO: Skill damage isn't 100%, so far it's been +-10 which is realy good, but not quite there! Other stats are 99.9%
	_CHARACTER_DATA* pChar = sObjMgr->GetCharacterInfo(m_userData->m_charType);
	uint32 totalStats[STAT_END]{ 0, 0, 0, 0, 0, 0 };
	uint32 totalNatureStats = 0;
	m_accuracy = 0;
	m_dodge = 0;
	m_attackSpeed = 0;
	m_crit = 5;
	m_movementSpeed = 6;
	m_maxHp = pChar->m_baseHp;
	m_maxChi = pChar->m_baseChi;

	for (int i = 0; i < STAT_END; i++)
	{
		totalStats[i] += m_userData->m_stats[i];
		totalStats[i] += m_itemStatBonus[i];

		if (i > STAT_INT)
			totalNatureStats += totalStats[i];
	}

	m_maxHp += m_itemMaxHp + (pChar->m_hpPerLevel * (GetLevel() - 1)) + (totalStats[STAT_STR] * HP_PER_STR);
	m_maxChi += m_itemMaxChi + (pChar->m_chiPerLevel * (GetLevel() - 1)) + (totalStats[STAT_INT] * CHI_PER_INT);

	m_minDamage = (((pChar->m_dmgPerLevel * (GetLevel() - 1) + DMG_PER_STR * totalStats[STAT_STR]) + m_itemMinDmg + m_itemMinBonusDmg + DMG_PER_NATURE_STAT * totalNatureStats) * (1.0f + (float)m_itemBonusDmgPercent / 100));
	m_maxDamage = (((pChar->m_dmgPerLevel * (GetLevel() - 1) + DMG_PER_STR * totalStats[STAT_STR]) + m_itemMaxDmg + m_itemMaxBonusDmg + DMG_PER_NATURE_STAT * totalNatureStats) * (1.0f + (float)m_itemBonusDmgPercent / 100));

	//m_minSkillDamage = (((pChar->m_sdmgPerLevel + 0.025 * ((GetLevel() / 10) - 1)) * (GetLevel() - 1) + (SDMG_PER_STR * totalStats[STAT_STR]) + (SDMG_PER_INT * totalStats[STAT_INT]) + (m_minDamage * 0.1) + ((1.0f + totalStats[STAT_INT] / 100) * m_itemMinDmg)) * (1.0f + ((float)m_itemBonusDmgPercent / 100 + (float)m_itemBonusSDmgPercent / 100))) + m_itemMinBonusSDmg;
	//m_maxSkillDamage = (((pChar->m_sdmgPerLevel + 0.025 * ((GetLevel() / 10) - 1)) * (GetLevel() - 1) + (SDMG_PER_STR * totalStats[STAT_STR]) + (SDMG_PER_INT * totalStats[STAT_INT]) + (m_maxDamage * 0.1) + ((1.0f + totalStats[STAT_INT] / 100) * m_itemMaxDmg)) * (1.0f + ((float)m_itemBonusDmgPercent / 100 + (float)m_itemBonusSDmgPercent / 100))) + m_itemMaxBonusSDmg;
	//m_minSkillDamage = (m_minDamage * (1.0f + totalStats[STAT_INT] / 94)) * (1.0f + m_itemBonusSDmgPercent / 100) + m_itemMinBonusSDmg;
	//m_maxSkillDamage = (m_maxDamage * (1.0f + totalStats[STAT_INT] / 94)) * (1.0f + m_itemBonusSDmgPercent / 100) + m_itemMaxBonusSDmg;
	m_minSkillDamage = (SDMG_PER_NATURE_STAT * totalNatureStats + pChar->m_sdmgPerLevel * (GetLevel() - 1) + 0.05f * m_minDamage * pow(m_userData->m_stats[STAT_INT], 0.779f)) * (1.0f + (float)m_itemBonusSDmgPercent / 100);
	m_maxSkillDamage = (SDMG_PER_NATURE_STAT * totalNatureStats + pChar->m_sdmgPerLevel * (GetLevel() - 1) + 0.05f * m_maxDamage * pow(m_userData->m_stats[STAT_INT], 0.779f)) * (1.0f + (float)m_itemBonusSDmgPercent / 100);

	m_def = ((pChar->m_defPerLevel * GetLevel()) + m_itemDefense + DEF_PER_DEX * totalStats[STAT_DEX] + DEF_PER_NATURE_STAT * totalNatureStats) * (1.0f + (float)m_itemDefensePercent / 100);
	m_skillDef = ((pChar->m_sdefPerLevel * GetLevel()) + m_itemSDefense + SDEF_PER_DEX * totalStats[STAT_DEX] + SDEF_PER_INT * totalStats[STAT_INT]+ SDEF_PER_NATURE_STAT * totalNatureStats) * (1.0f + (float)m_itemSDefensePercent / 100);

	m_accuracy += m_itemAccuracy + ACC_PER_STR * totalStats[STAT_STR];
	m_dodge += m_itemDodge + DODGE_PER_DEX * totalStats[STAT_DEX];

	m_crit += m_itemCritChance + CRIT_PER_DEX * totalStats[STAT_DEX];
	/*if (m_userData->m_itemArray[m_userData->m_activeWeapon].itemId == 0)
		m_attackSpeed = (1000 - (ATKSPD_PER_DEX * (totalStats[STAT_DEX] - 1))) * 10;
	else
		m_attackSpeed = (m_itemDelay - (ATKSPD_PER_DEX * (totalStats[STAT_DEX] - 1))) * 10;*/
	m_attackSpeed = (100 + ATKSPD_PER_DEX * (totalStats[STAT_DEX] - 1)) * 10;
	m_movementSpeed += m_itemMovementSpeed;

	m_poisonAtk = m_itemPoisonDmg;
	m_poisonDef = m_itemPoisonDef;
	m_confusionAtk = m_itemConfusionDmg;
	m_confusionDef = m_itemConfusionDef;
	m_paralysisAtk = m_itemParalysisDmg;
	m_paralysisDef = m_itemParalysisDef;

	SendCharacterUpdate();
	SendUpdateHpAndChi(NULL);
}

void CUser::SendRegionCharacterUpdate()
{
	Packet result(PKT_GAMESERVER_REGION_CHANGE_USER, uint8(1));
	result.append(GetUserInfoForRegion());
	//SERVER_INSTANCE_CHANGE
	SendToRegion(result, NULL);
	//g_main->SendToRegion(result, GetMap(), GetRegionX(), GetRegionZ(), NULL);
}

//Packet #21
ByteBuffer CUser::GetUserInfoForRegion()
{
	//TODO: Also we have a crash on login sometimes.
	//Replace SendRegionCharacterUpdate stuff with UserLeaveEnterRegion.
	//Also find size in here. It's somewhere!
	//after that i guess figure out the visual bugs ingame when like changing combat state.
	//TODO: Also fix having max hp/chi then removing an item doesn't set your curHP to new maxHP. Think hero does this in the time regen thing.
	//TODO: Keep working on skills. Alot of bugs there still! Working is basicaly adding them, saves to DB. Gotta delete the book from inv too(eeasy
	//TODO: Add implementation for showing correct colors when showing damage on the client, seems to be in the 16 packet, it sends skill id when it's a skill(weird as fuck)
	//TODO: Implement npc region out when exiting rX + 1(still show regions around you).
	int len;
	uint8* arr;
	ByteBuffer result;
	//Packet result(0x21); //Character update when entering a region
	//result << uint8(0x01);//Enter
	result << GetID();//Socket id
	//1D560000
	result << m_userData->m_charUniqueId;
	result << m_abnormalType;//TODO: Figure the abnormal type
	arr = HEXSTRTOBYTEARR2("01000000", len);// On sitama this was, after 1d56 00000401000000 01 might be non store, 02 store? 4 means blink, 3 non blink 1 might mean visible to players, so that's why stores have 2
	//result << uint8(0x01);//enter?
	//arr = HEXSTRTOBYTEARR2("2403d90d00000401000000", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;
	//name 0A78584D65726C696E5878
	result << m_userData->m_charId;
	//level
	result << GetLevel();//uint32(0x0000009F);
	result << m_userData->m_charType;//char type was 3E monk div
	result << m_userData->m_class;//class?
	arr = HEXSTRTOBYTEARR2("0100201C000002", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;
	//X Z Y?
	//22F0FD42 97DEBC43 ?E3366FC1?
	result << m_userData->m_curPosX << m_userData->m_curPosZ << m_userData->m_curPosY;
	//result << float(-15);
	//TODO: This is probably where the guy is moving
	//0000F642 0080C143 00DA6CC1
	result << m_userData->m_curPosX << m_userData->m_curPosZ << m_userData->m_curPosY;
	//66665641
	result << m_movementSpeed;
	//result << float(-15);
	//Item info after FFFFFFFF07, structure is the same as login screen char info.
	//									9729 fame		CE2D hp							37 00 00 00 0D has to do with clans, check NewMunpaData(clanData)
	arr = HEXSTRTOBYTEARR2("FFFF97290000C8000000CE2D0000F04F010001112700000101", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;
	//04
	result << m_userData->m_activeWeapon;
	//I think F303 is attack speed(1019 / 10) 101.9 on client.
	arr = HEXSTRTOBYTEARR2("F30300000005", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;
	//00000000
	result << m_userData->m_morphId;
	arr = HEXSTRTOBYTEARR2("320000003E370000000D000000010000000064FFFFFFFF", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;

	//Equipped stuff visible only, 07 count? 076BF2C9013301A60700000000B50FCB013401A20400000000E3B7EF000200A50300000000D02BA8000300A20300000000248A09010400A40400000000E1B7EF000900A50300000000000000000A00000000000000000000
	result.append(GetVisibleItemList());

	result << uint8(0x00) << uint16(0x00);//Unk
	return result;
}

void CUser::ExpChange(uint64 exp)
{
	ASSERT(m_userData->m_exp >= 0);

	//TODO: We want to move the loop here i'm pretty sure, add the exp and save the exp above the req, then do the levelup stuff. Then we check again etc..
	//Pretty sure what we do now makes the client not update the actual bar correctly. % is fine, filling isn't
	exp *= (1.0f + (double)m_itemBonusExp / 100);
	m_userData->m_exp += exp;

	SendExpChange();

	//Check for levelup
	while (m_userData->m_exp >= g_main->GetExpReqByLevel(GetLevel()))
	{
		if (GetLevel() < 250) //TODO: Add definition for this
		{
			LevelChange(++m_userData->m_level);
			UserLeaveEnterRegion(1);
		}
		else
			m_userData->m_exp = g_main->GetExpReqByLevel(GetLevel());
	}
}

void CUser::SendExpChange()
{
	Packet result(PKT_GAMESERVER_UPDATE_CHARACTER_EXP);
	result << m_userData->m_exp;
	result << GetFreeSkillPoints();//Could be statpt exp
	Send(&result);
}

void CUser::LevelChange(uint32 newLevel)
{
	if (newLevel < 1 || newLevel > 250)
		return;

	UpdateUserStats();
	SendCharacterUpdate();
}

std::string CUser::GetLevelString()
{
	uint16 level = m_userData->m_level;
	if (level < 10)
		return string_format("%dKyu", level);
	if (level <= 100)
		return string_format("%dDan %dKyu", (uint16)floor(level / 10), (level % (uint16)floor(level / 10)));
	if (level < 110)
		return string_format("Divine %dKyu", level - 100);
	if (level <= 200)
		return string_format("Divine %dDan %dKyu", (uint16)floor((level - 100) / 10), (level % (uint16)floor(level / 10)));
	if (level < 210)
		return string_format("Darkness %dKyu", level - 200);
	if (level <= 250)
		return string_format("Darkness %dDan %dKyu", (uint16)floor((level - 200) / 10), (level % (uint16)floor(level / 10)));

	return "LEVEL STRING ERROR";
}

void CUser::SendMorphPlayer()
{
	Packet result;
	//If there's no NPC id stored that means we demorph
	if (m_userData->m_morphId == 0)
	{
		result.Initialize(PKT_GAMESERVER_DEMORPH_PLAYER);
		Send(&result);
	}
	else
	{
		result.Initialize(PKT_GAMESERVER_MORPH_PLAYER);

		if (sObjMgr->GetNpcInfo(m_userData->m_morphId) == NULL)
			return;
		result << m_userData->m_morphId;
		Send(&result);
	}

	SendRegionCharacterUpdate();
}

void CUser::SendUnk75()
{
	Packet result(0x75);
	uint8* arr;
	int len;

	arr = HEXSTRTOBYTEARR2("00010080a14300003d43", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;

	Send(&result);
}

void CUser::SendUpdateHpAndChi(Unit* pTarget)
{
	//Update hp/chi and something else idk what the fuck it is
	Packet result(PKT_GAMESERVER_CHARACTER_UPDATE_CURHPCHI);
	result << GetID();
	if (pTarget != NULL)
		result << pTarget->GetID();
	else
		result << GetID();
	//2d2f0000
	result << uint32(m_userData->m_curHp);
	//a2120000
	result << uint32(m_userData->m_curChi);
	int len;
	uint8* arr;
	arr = HEXSTRTOBYTEARR2("000000000000000000000000000000000000000000000032000000", len);
	foreach_array_n(i, arr, len)
		result << arr[i];
	delete[] arr;

	//if (pTarget != NULL)
		//SERVER_INSTANCE_CHANGE
		SendToRegion(result, NULL);
		//g_main->SendToRegion(result, GetMap(), GetRegionX(), GetRegionZ(), NULL);
	//else
		//Send(&result);
}

void CUser::SendMyInfo()
{
	Packet result(0x08);
	//ByteBuffer temp, temp2;
	uint8* arr;
	int len = 0;

	//arr = HEXSTRTOBYTEARR2("AE02D90D0000", len);
	result << GetID();
	//1D560000
	result << m_userData->m_charUniqueId;
	result << m_userData->m_charId;//20 max?
							//45
	result << m_userData->m_charType;//Skill books get fucked when non div here(can't have all skill books)
									 //warlord, 1f
	result << m_userData->m_class;
	result << m_abnormalType;//uint8(0x03);//TODO: Figure out abnormal type
						//10
	result << m_userData->m_zone;
	//08A67C430C68784286EF2941
	result << m_userData->m_curPosX << m_userData->m_curPosZ << m_userData->m_curPosY;
	//97
	result << m_userData->m_level;//Unk(level)
	result << m_userData->m_fame;
	result << uint32(0x000000C8);//This has to do with Widen? also a flag that tells the game some special char effect
								 //9600960014001400AB03AB030000000000000000C800C800
	result << m_userData->m_stats[STAT_STR] << uint16(m_userData->m_stats[STAT_STR] + m_itemStatBonus[STAT_STR]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_DEX] << uint16(m_userData->m_stats[STAT_DEX] + m_itemStatBonus[STAT_DEX]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_INT] << uint16(m_userData->m_stats[STAT_INT] + m_itemStatBonus[STAT_INT]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_WIND] << uint16(m_userData->m_stats[STAT_WIND] + m_itemStatBonus[STAT_WIND]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_WATER] << uint16(m_userData->m_stats[STAT_WATER] + m_itemStatBonus[STAT_WATER]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_FIRE] << uint16(m_userData->m_stats[STAT_FIRE] + m_itemStatBonus[STAT_FIRE]); // stat + itemBonusStats
	result << GetFreeStatPoints();
	result << GetFreeElementPoints();
	//E7000000
	result << GetFreeSkillPoints() << uint16(0x0000);//Unk
													 //1C69027A36000000
	result << m_userData->m_exp;
	//2AF5E67C36000000
	result << g_main->GetExpReqByLevel(GetLevel());
	result << uint32(0x00001C20);//Unk 201C0000
								 //2D2F000053310000
	result << (uint32)m_userData->m_curHp << m_maxHp;
	//DC130000DC130000
	result << (uint32)m_userData->m_curChi << m_maxChi;
	//00000000
	result << m_userData->m_injury * 1000;
	//0003
	result << uint8(0x00) << m_userData->m_activeWeapon;
	//011E0101
	result << uint8(1) << uint8(m_userData->m_showHtItems) << m_userData->m_showHelm << m_userData->m_showMask;
	//02
	result << m_userData->m_height;
	//00000000
	result << m_userData->m_hair;//TODO: Not sure if this is correct. get back to it.
								 //00000000
	result << m_userData->m_face; //Last part is date time string 2016-02-06 02:52:46
	//00010004
	result << uint8(0);
	result << uint8(1);
	result << uint8(0);
	result << uint8(4);
	//D18ED70200000000
	result << m_userData->m_gold;
	//14A493D600000000
	result << m_userData->m_warehouseGold;
	arr = HEXSTRTOBYTEARR2("00000000000000000000000000000000000000000000000000000000000000000000000000000000000002323031362D30322D30362030323A35323A343600", len);
	foreach_array_n(i, arr, len)
		result << arr[i];
	delete[] arr;
	//2E00
	uint16 counter = 0;
	ByteBuffer bTemp;
	for (int i = 0; i < IS_END; i++)
	{
		_ITEM_DATA* pItem = &m_userData->m_itemArray[i];
		if (pItem->itemId == 0)
			continue;
		counter++;

		_ITEM_TABLE* pTable = sObjMgr->GetItemTemplate(pItem->itemId);

		bTemp << pItem->itemId << uint8(0x00);
		bTemp << pTable->m_itemRarity << pItem->count;
		bTemp << uint16(i);

		if (pTable->m_itemRarity < 0xA2 && pTable->m_itemRarity != 0 && (pItem->GetUpgradeCount() == 0 && pItem->GetHoleCount() == 0))//Can't have + i think.
		{
			bTemp << uint32(0x00000000); //Delimeter?
			continue;
		}

		foreach_array_n(j, pItem->upgrades, MAX_ITEM_UPGRADE_AMOUNT)
			bTemp << pItem->upgrades[j];
		bTemp << pItem->holeCount;
		foreach_array_n(j, pItem->holes, MAX_ITEM_UPGRADE_AMOUNT - 1)
			bTemp << pItem->holes[j];
		bTemp << uint32(0x00000000); //Delimeter?
	}
	result << counter; //TODO: Need to fix/figure out the count things.
	result.append(bTemp);
	//result << uint16(0x0000);//uint16(0x002E); //Item count, equip 0-10 + inv slots
	result << uint16(0x0000);//CS stuff + 2nd accs
	result << uint16(0x0000);//Pet armors
	result << uint16(0x0000);//Five elements? or cashshop thing?
	result << uint16(0x0000);//2nd inventory
	result << uint16(0x0000);//Unk count?

							 //Skill books
	//for (int i = 0; i < 7; i++)//Books + stat on books
	//	result << uint32(0) << uint16(0) << uint8(0);//id + force etc
	////Skills in books and points taken.
	//for (int i = 0; i < 7 * 24; i++)
	//	result << uint32(0) << uint8(0);//id + pts spent
	for (int i = 0; i < MAX_EXPANDABLE_SKILLBOOKS; i++)
	{
		result << m_userData->m_skillBookArray[i].m_skillBookId;
		for (int j = 0; j < SPECIAL_PT_TYPE_END; j++)
			result << m_userData->m_skillBookArray[i].m_specialBookStats[j];
	}
	for (int i = 0; i < MAX_EXPANDABLE_SKILLBOOKS; i++)
	{
		_PLAYER_SKILL_BOOK_DATA* pData = &m_userData->m_skillBookArray[i];

		for (int j = 0; j < MAX_SKILLS_IN_BOOK; j++)
		{
			result << pData->m_skillData[j].m_skillId;
			result << pData->m_skillData[j].m_pointsSpent;
		}
	}
	for (int i = 0; i < 9; i++)//passives
		result << uint32(0) << uint8(0);//id + pts spent
	//result << uint16(0x0000);//five elements or cashshop thing?
	///THIS RIGHT HERE, QUESTS
	/*arr = HEXSTRTOBYTEARR2("000000000000323031362D30322D31332030393A34343A32380000323031362D30322D31332030393A34343A32390000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030303030303030303030303030003030303030303020202030202020203020202030202020302020302000303000000020200000002020202070300000000000000000000000000000000000000010003000000000000000000000000000000000000000000010000000000000000000000000000000000020202000A0000000000000100000000030000000000000000000000000000000000000000000000000000000000000000000000000003000202090502020202020202010202020002020000020201030303030303000300000000000000000303030300000000000000030000000000000003030003030003000303030003000300030300000000000300000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000302020202020202020202020202010202020202020400000000000000000000000000000203010300000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000202020202020202020202020202020202020202020202020202020202020202020200000000000002020300030202020000130000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020202010202010104000000000000000000000000000000000003000000000000000000030300000000010101010101010301010101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000100000000020202020102020200000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000170067000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000840000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000601000001000000000000000000000000000000000000000000000000000000000000000000000000000000000047010000040000000000000000000000000000000000000000000000000000000000000000000000000000000000580100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000C0200000100000000000000000000000000000000000000000000000000000000000000000000000000000000000F02000001000A0000000000000000000000000000000000000000000000000000000000000000000000000000001002000001000000000000000000000000000000000000000000000000000000000000000000000000000000000033020000010024000000FB0000001A01000000000000000000000000000000000000000000000000000000000000340200000100D9010000090000000D00000000000000000000000000000000000000000000000000000000000000350200000100270000000000000000000000000000000000000000000000000000000000000000000000000000003602000001001B0000000600000000000000000000000000000000000000000000000000000000000000000000003702000001000A00000001000000000000000000000000000000000000000000000000000000000000000000000038020000010000000000020000000000000000000000000000000000000000000000000000000000000000000000390200000100000000000800000000000000000000000000000000000000000000000000000000000000000000003B0200000100000000001300000000000000000000000000000000000000000000000000000000000000000000003C02000001001A0000000C00000000000000000000000000000000000000000000000000000000000000000000003D0200000100000000000400000000000000000000000000000000000000000000000000000000000000000000003E020000010000000000040000000000000000000000000000000000000000000000000000000000000000000000200300000100000000000000000000000000000000000000000000000000000000000000000000000000000000002A030000010000000000000000000000000000000000000000000000000000000000000000000000000000000000330300000100000000000000000000000000000000000000000000000000000000000000000000000000000000003A03000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000", len);
	foreach_array_n(i, arr, len)
	result << arr[i];*/
	//delete[] arr;

	Send(&result);
}

void CUser::SendCharacterUpdate()
{
	uint8* arr;
	int len;

	Packet result(0x14);//Char info packet	
	result << uint32(m_userData->m_level);
	result << uint8(0x02);//Unk
	result << uint16(0x0000);//Unk
	result << uint8(0x00);
	//0708
	result << GetFreeStatPoints();
	//090A
	result << GetFreeElementPoints();
	//E7000000
	result << GetFreeSkillPoints();
	result << uint16(0x0000); //Unk
							  //1c69027a Req exp
	result << m_userData->m_exp;
	result << uint8(0x20);//Unk
	result << uint32(0x0000001c);//Unk
	result << g_main->GetExpReqByLevel(GetLevel());
	result << m_userData->m_stats[STAT_STR] << uint16(m_userData->m_stats[STAT_STR] + m_itemStatBonus[STAT_STR]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_DEX] << uint16(m_userData->m_stats[STAT_DEX] + m_itemStatBonus[STAT_DEX]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_INT] << uint16(m_userData->m_stats[STAT_INT] + m_itemStatBonus[STAT_INT]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_WIND] << uint16(m_userData->m_stats[STAT_WIND] + m_itemStatBonus[STAT_WIND]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_WATER] << uint16(m_userData->m_stats[STAT_WATER] + m_itemStatBonus[STAT_WATER]); // stat + itemBonusStats
	result << m_userData->m_stats[STAT_FIRE] << uint16(m_userData->m_stats[STAT_FIRE] + m_itemStatBonus[STAT_FIRE]); // stat + itemBonusStats
																						//9600c00014003e00ab03cb03 stat info, str strB, dex dexB, int intBonus int idk why it looks like this realy
																						//00001f0000001f00c800e700 Wind WindBonus water WaterBouns fire fireBonus
																						//fb030000 seems to be attack speed
	//009a992941
	result << uint8(0);
	result << m_movementSpeed;
	arr = HEXSTRTOBYTEARR2("66668641", len);
	foreach_array_n(i, arr, len)
		result << arr[i];
	delete[] arr;
	//fb030000
	result << m_attackSpeed;
	result << uint16(0x4000);//Unk
							 //2d2f0000 dc130000
	result << m_maxHp;// << m_userData->m_baseHp;
	result << m_maxChi;// << m_userData->m_baseChi;
					   //D20A930D min max damage
	result << m_minDamage << m_maxDamage;
	//5e0e0000 5e0e0000 5e0e0000 TODO: Why are these sent 3 times idk..
	result << m_def; //Figure this out more, now pvp def is incorrect.
	result << m_def; //Idk why they send it 3 times, This one seems to be actual def.
	result << m_def;
	//9dc40000 11f60000 min max skill damage
	result << m_minSkillDamage << m_maxSkillDamage;
	//dd290000
	result << m_skillDef;
	//4b011001 dodge + acc
	result << m_accuracy;
	result << m_dodge;
	//0500
	result << uint16(0x0005); //Unk
	//0000a50000
	result << m_poisonAtk << m_poisonDef << uint8(0x00); //last is unk
														 //1600880000
	result << m_confusionAtk << m_confusionDef << uint8(0x00);
	//0000b60000
	result << m_paralysisAtk << m_paralysisDef << uint8(0x00);
	//0000000000000000
	result << m_pvpDamage; //+m_damage thing?
	result << m_pvpSkillDamage;
	//5e0e0000
	result << m_pvpDef + m_def;
	//dd290000 all these are basicly pvp = m_pvpdef - m_def client side so we send the combined value, if there's no pvp def the client will display 0.
	result << m_pvpSkillDef + m_skillDef;
	result << uint8(0x00);//Unk
	result << uint16(0xffff);//Unk

							 //303130392d30362d31392031323a30303a30300039302e3232372e3139332e3630
	char tempArr[19];
	time_t rawtime;
	time(&rawtime);
	struct tm timeinfo;
	localtime_s(&timeinfo, &rawtime);
	strftime(tempArr, sizeof(tempArr) - 1, "%d.%m.%y %H:%M:%S", &timeinfo);
	for (int i = 0; i < sizeof(tempArr); i++)
		result << tempArr[i];
	//Something here might be rotation, rest i have no clue, doesn't seem to affect anything visible ingame
	arr = HEXSTRTOBYTEARR2("00000000000000040000000064007c02000087020000a00000000000803f0000803f", len);
	for (int i = 0; i < len; i++)
		result << arr[i];
	delete[] arr;

	Send(&result);
}

void CUser::SendNotice(std::string msg)
{
	Packet result(PKT_GAMESERVER_MESSAGE, uint8(MT_PLAYER_NOTICE));
	result.SByte();

	result << msg;
	Send(&result);
}

void CUser::SendGlobalNotice(std::string msg)
{
	Packet result(PKT_GAMESERVER_MESSAGE, uint8(MT_PLAYER_NOTICE));
	result.SByte();

	result << msg;
	g_main->SendToAll(result);
}

CUser::~CUser()
{

}


//MEGADINGUS
//AA 55 C3 00 17 BE 00 EB 0C 1F E9 0C 08 FE 01 8E 7D 00 00 0A 4D 65 67 61 44 69 6E 67 75 73 38 02 03 01 00 00 25 43 00 80 AB 43 03 00 00 A0 41 20 0C 03 00 10 27 00 60 00 00 0F 20 01 00 0A 20 01 00 05 20 01 E0 03 00 00 04 E0 03 0C 60 00 00 64 60 05 06 00 00 20 1C 00 00 5D 20 07 00 F6 20 03 00 18 20 03 00 CC 20 03 60 00 01 03 01 20 00 60 09 60 00 02 01 00 03 60 07 20 00 03 14 A4 93 D6 20 06 E0 37 00 0A 02 00 B3 07 0B 01 00 A1 01 00 0B 60 4A 02 C0 75 06 60 0D 00 0C 60 0D E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 CF 00 E5 00 65 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 B5 00 01 00 00 55 AA 

//AA 55 C1 00 17 BC 00 EB 0C 1F E9 0C 08 5E 02 8E 7D 00 00 0A 4D 65 67 61 44 69 6E 67 75 73 38 02 03 01 B7 7E 25 43 5B BF AB 43 09 00 00 A0 41 01 00 00 00 10 27 20 04 20 00 00 0F 20 01 00 0A 20 01 00 05 20 01 E0 03 00 00 04 E0 03 0C 60 00 00 64 60 05 06 00 00 20 1C 00 00 5D 20 07 00 F6 20 03 00 18 20 03 A0 48 03 00 00 03 01 20 00 20 07 A0 00 02 01 00 03 A0 09 04 00 14 A4 93 D6 C0 0B E0 32 00 0A 02 00 B3 07 0B 01 00 A1 01 00 0B 60 45 02 C0 75 06 60 0D 00 0C 60 0D E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 CF 00 E5 00 65 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 B5 00 01 00 00 55 AA 

//PaperPaper...
//AA 55 BF 00 17 BA 00 F3 0C 0E F1 0C 08 6A 01 CF 85 00 00 12 70 61 70 65 72 E0 04 04 0F 38 02 00 01 00 00 25 43 00 80 AB 43 00 00 A0 41 20 0C 03 00 10 27 00 60 00 00 0F 20 01 00 0A 20 01 00 05 20 01 E0 03 00 00 04 E0 03 0C 60 00 00 64 60 05 06 00 00 20 1C 00 00 F6 20 07 40 03 00 18 20 07 A0 48 03 00 00 03 01 20 00 20 07 A0 00 02 01 00 03 A0 09 04 00 14 A4 93 D6 C0 0B E0 32 00 0A 02 00 B3 07 0B 01 00 A1 01 00 0B 60 45 02 C0 75 06 60 0D 00 0C 60 0D E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 02 00 E6 00 A8 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 FF 00 E0 7A 00 01 00 00 55 AA 
